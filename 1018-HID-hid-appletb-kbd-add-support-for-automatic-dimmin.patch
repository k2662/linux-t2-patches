From 9f042a8ed567fbf52d612895fc09c70c60fc3877 Mon Sep 17 00:00:00 2001
From: Aditya Garg <gargaditya08@live.com>
Date: Tue, 20 Aug 2024 18:37:19 +0530
Subject: [PATCH] HID: hid-appletb-kbd: add support for automatic dimming of
 touchbar backlight

The touchbar on Windows Bootcamp drivers dims automatically if there is no
input from the keyboard, trackpad or touchbar. If still left idle, it turns
off.

On Windows, the dim timeout is 60 seconds and it takes further 15 seconds to
turn it off. Do the same for Linux, and make it configurable using the
dim_timeout and idle_timeout module parameters.

Signed-off-by: Aditya Garg <gargaditya08@live.com>
---
 drivers/hid/hid-appletb-kbd.c | 71 +++++++++++++++++++++++++++++++++--
 1 file changed, 67 insertions(+), 4 deletions(-)

diff --git a/drivers/hid/hid-appletb-kbd.c b/drivers/hid/hid-appletb-kbd.c
index 442c4d884..6465c6b4c 100644
--- a/drivers/hid/hid-appletb-kbd.c
+++ b/drivers/hid/hid-appletb-kbd.c
@@ -16,6 +16,8 @@
 #include <linux/bitops.h>
 #include <linux/module.h>
 #include <linux/string.h>
+#include <linux/backlight.h>
+#include <linux/timer.h>
 #include <linux/input/sparse-keymap.h>
 
 #include "hid-ids.h"
@@ -27,6 +29,7 @@
 #define APPLETB_KBD_MODE_MAX	APPLETB_KBD_MODE_OFF
 
 #define APPLETB_DEVID_KEYBOARD	1
+#define APPLETB_DEVID_TRACKPAD	2
 
 #define HID_USAGE_MODE		0x00ff0004
 
@@ -41,14 +44,25 @@ static bool appletb_tb_fn_toggle = true;
 module_param_named(fntoggle, appletb_tb_fn_toggle, bool, 0644);
 MODULE_PARM_DESC(fntoggle, "Switch between Fn and media controls on pressing Fn key");
 
+static int appletb_tb_dim_timeout = 60;
+module_param_named(dim_timeout, appletb_tb_dim_timeout, int, 0644);
+MODULE_PARM_DESC(dim_timeout, "Dim timeout in sec");
+
+static int appletb_tb_idle_timeout = 15;
+module_param_named(idle_timeout, appletb_tb_idle_timeout, int, 0644);
+MODULE_PARM_DESC(idle_timeout, "Idle timeout in sec");
+
 struct appletb_kbd {
 	struct hid_field *mode_field;
-
-	u8 saved_mode;
-	u8 current_mode;
 	struct input_handler inp_handler;
 	struct input_handle kbd_handle;
-
+	struct input_handle tpd_handle;
+	struct backlight_device *backlight_dev;
+	struct timer_list inactivity_timer;
+	bool has_dimmed;
+	bool has_turned_off;
+	u8 saved_mode;
+	u8 current_mode;
 };
 
 static const struct key_entry appletb_kbd_keymap[] = {
@@ -146,6 +160,32 @@ static int appletb_tb_key_to_slot(unsigned int code)
 	}
 }
 
+static void appletb_inactivity_timer(struct timer_list *t)
+{
+	struct appletb_kbd *kbd = from_timer(kbd, t, inactivity_timer);
+
+	if (kbd->backlight_dev) {
+		if (!kbd->has_dimmed) {
+			backlight_device_set_brightness(kbd->backlight_dev, 1);
+			kbd->has_dimmed = true;
+			mod_timer(&kbd->inactivity_timer, jiffies + msecs_to_jiffies(appletb_tb_idle_timeout * 1000));
+		} else if (!kbd->has_turned_off) {
+			backlight_device_set_brightness(kbd->backlight_dev, 0);
+			kbd->has_turned_off = true;
+		}
+	}
+}
+
+static void reset_inactivity_timer(struct appletb_kbd *kbd)
+{
+	if ((kbd -> has_dimmed || kbd -> has_turned_off) && kbd->backlight_dev) {
+		backlight_device_set_brightness(kbd->backlight_dev, 2);
+		kbd->has_dimmed = false;
+		kbd->has_turned_off = false;
+		mod_timer(&kbd->inactivity_timer, jiffies + msecs_to_jiffies(appletb_tb_dim_timeout * 1000));
+	}
+}
+
 static int appletb_kbd_hid_event(struct hid_device *hdev, struct hid_field *field,
 				      struct hid_usage *usage, __s32 value)
 {
@@ -170,6 +210,8 @@ static int appletb_kbd_hid_event(struct hid_device *hdev, struct hid_field *fiel
 	if (slot < 0)
 		return 0;
 
+	reset_inactivity_timer(kbd);
+
 	translation = sparse_keymap_entry_from_scancode(input, usage->code);
 
 	if (translation && kbd->current_mode == APPLETB_KBD_MODE_SPCL) {
@@ -186,6 +228,8 @@ static void appletb_kbd_inp_event(struct input_handle *handle, unsigned int type
 {
 	struct appletb_kbd *kbd = handle->private;
 
+	reset_inactivity_timer(kbd);
+
 	if (type == EV_KEY && code == KEY_FN && appletb_tb_fn_toggle) {
 		if (value == 1) {
 			kbd->saved_mode = kbd->current_mode;
@@ -211,6 +255,9 @@ static int appletb_kbd_inp_connect(struct input_handler *handler,
 	if (id->driver_info == APPLETB_DEVID_KEYBOARD) {
 		handle = &kbd->kbd_handle;
 		handle->name = "tbkbd";
+	} else if (id->driver_info == APPLETB_DEVID_TRACKPAD) {
+		handle = &kbd->tpd_handle;
+		handle->name = "tbtpd";
 	} else {
 		return -ENOENT;
 	}
@@ -284,6 +331,15 @@ static const struct input_device_id appletb_kbd_input_devices[] = {
 		.keybit = { [BIT_WORD(KEY_FN)] = BIT_MASK(KEY_FN) },
 		.driver_info = APPLETB_DEVID_KEYBOARD,
 	},
+	{
+		.flags = INPUT_DEVICE_ID_MATCH_BUS |
+			INPUT_DEVICE_ID_MATCH_VENDOR |
+			INPUT_DEVICE_ID_MATCH_KEYBIT,
+		.bustype = BUS_USB,
+		.vendor = USB_VENDOR_ID_APPLE,
+		.keybit = { [BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH) },
+		.driver_info = APPLETB_DEVID_TRACKPAD,
+	},
 	{ }
 };
 
@@ -340,6 +396,12 @@ static int appletb_kbd_probe(struct hid_device *hdev, const struct hid_device_id
 		goto stop_hw;
 	}
 
+	timer_setup(&kbd->inactivity_timer, appletb_inactivity_timer, 0);
+	mod_timer(&kbd->inactivity_timer, jiffies + msecs_to_jiffies(appletb_tb_dim_timeout * 1000));
+	kbd->backlight_dev = backlight_device_get_by_name("appletb_backlight");
+		if (!kbd->backlight_dev)
+			dev_err_probe(dev, ret, "Failed to get backlight device\n");
+
 	kbd->inp_handler.event = appletb_kbd_inp_event;
 	kbd->inp_handler.connect = appletb_kbd_inp_connect;
 	kbd->inp_handler.disconnect = appletb_kbd_inp_disconnect;
@@ -378,6 +440,7 @@ static void appletb_kbd_remove(struct hid_device *hdev)
 	appletb_kbd_set_mode(kbd, APPLETB_KBD_MODE_OFF);
 
 	input_unregister_handler(&kbd->inp_handler);
+	del_timer_sync(&kbd->inactivity_timer);
 
 	hid_hw_close(hdev);
 	hid_hw_stop(hdev);
-- 
2.43.0

